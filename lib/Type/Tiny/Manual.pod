=pod

=encoding utf-8

=head1 NAME

Type::Tiny::Manual - an overview of Type::Tiny

=head1 SYNOPSIS

Type::Tiny is a small framework for writing type constraints and organising
them into type libraries. Although inspired by Moose's type constraint API,
it has no non-core dependencies, and can be used with L<Moose>, L<Mouse> and
L<Moo>.

It provides a small Moose-inspired library of built-in type constraints.

=head1 SEE ALSO

=over

=item *

L<Libraries|Type::Tiny::Manual::Libraries> - how to build a type library with Type::Tiny, Type::Library and Type::Utils

=item *

L<Using with Moose|Type::Tiny::Manual::UsingWithMoose> - how to use Type::Tiny and Type::Library with Moose

=item *

L<Using with Mouse|Type::Tiny::Manual::UsingWithMouse> - how to use Type::Tiny and Type::Library with Mouse

=item *

L<Using with Moo|Type::Tiny::Manual::UsingWithMoo> - how to use Type::Tiny and Type::Library with Moo

=item *

Type::Tiny and friends don't need to be used within an OO framework. See L<FreeMind::Node> for an example that does not.

=back

=head1 TYPE::TINY VERSUS X

=head2 Specio 

Type::Tiny is similar in aim to L<Specio>. The major differences are that
Type::Tiny is "tiny"; and Type::Tiny dispenses with the idea of a type
registry and stringy access to type constraints.

=head2 MooseX::Types

Type::Tiny libraries expose a similar interface to L<MooseX::Types> libraries.
In most cases you should be able to rewrite a L<MooseX::Types> library to
use Type::Tiny pretty easily.

=head2 MooX::Types::MooseLike

Type::Tiny is faster and supports coercions.

=head1 CAVEATS

=head2 Mutability of Type::Coercion

Type::Tiny type constraints are designed as immutable objects. Once you've
created a constraint, rather than modifying it you generally create child
constraints to do what you need.

Type::Coercion objects, on the other hand, are mutable. Coercion routines
can be added at any time during the object's lifetime.

This combination of features means that if you create a Type::Tiny type
constraint, then create a Moose or Mouse type from it (the C<moose_type>
and C<mouse_type> lazily built attributes), and then add coercions to the
Type::Tiny constraint, the Moose/Mouse constraint will not see them.

In general you should avoid adding coercions to a type constraint once the
type constraint has started being used. Add coercions straight after defining
the type. The C<plus_coercions> method (which returns a new type constraint
with extra coercions, so doesn't violate immutability) is a better technique
than adding coercions willy-nilly during the course of a constraint's
lifetime.

I I<do> consider this to be an issue that needs resolving in a future
release. The likely solution will be to have the ability to "freeze" a
Type::Coercion object, and then change the C<moose_type> and C<mouse_type>
lazy builders to make them automatically freeze the type's associated
coercion.

=head1 AUTHOR

Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

=head1 COPYRIGHT AND LICENCE

This software is copyright (c) 2013 by Toby Inkster.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=head1 DISCLAIMER OF WARRANTIES

THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

=cut

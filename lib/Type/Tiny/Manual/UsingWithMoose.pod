=pod

=encoding utf-8

=head1 NAME

Type::Tiny::Manual::UsingWithMoose - how to use Type::Tiny and Type::Library with Moose

=head1 SYNOPSIS

   {
      package Person;
      
      use Moose;
      use Types::Standard -moose, qw( Str Int );
      use Type::Utils qw( declare as where inline_as coerce from );
      
      has name => (
         is      => "ro",
         isa     => Str,
      );
      
      my $PositiveInt = declare
         as        Int,
         where     {  $_ > 0  },
         inline_as { "$_ =~ /^0-9]\$/ and $_ > 0" };
      
      coerce $PositiveInt, from Int, q{ abs $_ };
      
      # Note that $PositiveInt is a Type::Tiny object, not a
      # Moose::Meta::TypeConstraint object, so when passing it
      # into Moose's "has" function you need to get the Moose
      # equivalent type using "->moose_type".
      #
      has age => (
         is      => "ro",
         isa     => $PositiveInt->moose_type,
         coerce  => 1,
         writer  => "_set_age",
      );
      
      sub get_older {
         my $self = shift;
         my ($years) = @_;
         $PositiveInt->assert_valid($years);
         $self->_set_age($self->age + $years);
      }
   }

=head1 DESCRIPTION

L<Type::Tiny> type constraints have an API almost identical to that of
L<Moose::Meta::TypeConstraint>.

Almost. But not quite good enough to trick Moose. This means that any
time you want to pass a Type::Tiny constraint into Moose (e.g. the C<isa>
option when defining an attribute) you need to convert it into a I<real>
Moose::Meta::TypeConstraint object. Luckily this is as simple as calling
the C<moose_type> method on the object. For example, see the C<isa> option
for C<age> in the SYNOPSIS.

As a shortcut, you can provide a C<< -moose >> option when importing from
a type library

   use Types::Standard -moose, qw( Str Int );

... and the imported bareword type constraint functions will automagically
return Moose-compatible types. For example, the C<Str> type used as the
constraint for C<name> in the SYNOPSIS.

You may prefer instead to import the standard Type::Tiny constraints and
call C<moose_type> as needed.

=head2 Per-Attribute Coercions

Type::Tiny offers convenience methods to alter the list of coercions
associated with a type constraint. And via a little cheeky monkey patching,
it also makes these methods available to Moose type constraint objects.
Let's imagine we wish to allow our C<name> attribute to be coerced from an
arrayref of strings.

      has name => (
         is      => "ro",
         isa     => Str->plus_coercions(
            ArrayRef[Str], sub { join " ", @{$_} },
         ),
         coerce  => 1,
      );

This coercion will apply to the C<name> attribute only; other attributes
using the C<Str> type constraint will be unaffected.

See the documentation for C<plus_coercions>, C<minus_coercions> and
C<no_coercions> in L<Type::Tiny>.

=head2 Optimization

The usual advice for optimizing type constraints applies: use type constraints
which can be inlined whenever possible.

Defining coercions as strings rather than coderefs won't give you as much of
a boost with Moose as it does with Moo, because Moose doesn't inline coercion
code. However, it should still improve performance somewhat because it allows
L<Type::Coercion> to do some internal inlining.

=head1 AUTHOR

Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

=head1 COPYRIGHT AND LICENCE

This software is copyright (c) 2013 by Toby Inkster.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=head1 DISCLAIMER OF WARRANTIES

THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

=cut
